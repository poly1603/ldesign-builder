# LDesign Builder - 扩展性设计

## 扩展性原则

LDesign Builder 的设计遵循开放封闭原则，对扩展开放，对修改封闭。通过插件系统、配置系统和钩子机制，用户可以在不修改核心代码的情况下扩展功能。

## 插件扩展系统

### 插件接口设计

```typescript
interface Plugin {
  name: string
  buildStart?: (options: InputOptions) => void
  resolveId?: (id: string, importer?: string) => string | null
  load?: (id: string) => string | null
  transform?: (code: string, id: string) => TransformResult | null
  generateBundle?: (options: OutputOptions, bundle: OutputBundle) => void
  writeBundle?: (options: OutputOptions, bundle: OutputBundle) => void
}

type PluginFactory = (context: BuildContext) => Promise<Plugin | null>
```

### 自定义插件注册

```typescript
import { PluginConfigurator } from '@ldesign/builder'

// 创建自定义插件
const myCustomPlugin: PluginFactory = async (context) => {
  return {
    name: 'my-custom-plugin',
    transform(code, id) {
      // 自定义转换逻辑
      return {
        code: transformedCode,
        map: sourceMap
      }
    }
  }
}

// 注册插件
const configurator = new PluginConfigurator()
configurator.registerPlugin('my-custom', myCustomPlugin)
```

### 插件优先级系统

```typescript
interface PluginConfig {
  name: string
  factory: PluginFactory
  priority: number  // 数字越大优先级越高
  condition?: (context: BuildContext) => boolean
}

class PluginConfigurator {
  private plugins: PluginConfig[] = []

  registerPlugin(config: PluginConfig): void {
    this.plugins.push(config)
    // 按优先级排序
    this.plugins.sort((a, b) => b.priority - a.priority)
  }
}
```

## 配置扩展系统

### 配置模式扩展

```typescript
interface BuildOptions {
  // 基础配置
  input: string | string[]
  outDir?: string
  formats?: OutputFormat[]
  
  // 扩展配置
  [key: string]: any
}

// 支持自定义配置字段
const config = defineConfig({
  input: 'src/index.ts',
  outDir: 'dist',
  
  // 自定义配置
  myCustomOption: {
    enabled: true,
    settings: {}
  }
})
```

### 配置验证扩展

```typescript
interface ConfigValidator {
  validate(config: BuildOptions): ValidationResult
}

class ConfigValidatorRegistry {
  private validators: ConfigValidator[] = []

  register(validator: ConfigValidator): void {
    this.validators.push(validator)
  }

  validateAll(config: BuildOptions): ValidationResult[] {
    return this.validators.map(v => v.validate(config))
  }
}
```

## 钩子系统

### 生命周期钩子

```typescript
interface BuildHooks {
  beforeScan?: (root: string, options: ScanOptions) => void | Promise<void>
  afterScan?: (result: ProjectScanResult) => void | Promise<void>
  beforeBuild?: (config: RollupOptions) => void | Promise<void>
  afterBuild?: (result: BuildResult) => void | Promise<void>
  onError?: (error: BuildError) => void | Promise<void>
}

class HookManager {
  private hooks: BuildHooks = {}

  register(hooks: Partial<BuildHooks>): void {
    Object.assign(this.hooks, hooks)
  }

  async execute<K extends keyof BuildHooks>(
    hookName: K,
    ...args: Parameters<NonNullable<BuildHooks[K]>>
  ): Promise<void> {
    const hook = this.hooks[hookName]
    if (hook) {
      await hook(...args)
    }
  }
}
```

### 钩子使用示例

```typescript
import { build, HookManager } from '@ldesign/builder'

const hookManager = new HookManager()

hookManager.register({
  beforeBuild: async (config) => {
    console.log('开始构建...')
    // 自定义预处理逻辑
  },
  
  afterBuild: async (result) => {
    console.log('构建完成!')
    // 自定义后处理逻辑
    if (result.success) {
      await uploadToServer(result.outputs)
    }
  },
  
  onError: async (error) => {
    console.error('构建失败:', error.message)
    await notifyDevelopers(error)
  }
})

await build({
  input: 'src/index.ts',
  outDir: 'dist',
  hooks: hookManager
})
```

## 文件处理器扩展

### 自定义文件类型处理

```typescript
interface FileProcessor {
  test: RegExp | ((filePath: string) => boolean)
  process: (content: string, filePath: string) => ProcessResult
}

interface ProcessResult {
  code: string
  map?: string
  dependencies?: string[]
}

class FileProcessorRegistry {
  private processors: FileProcessor[] = []

  register(processor: FileProcessor): void {
    this.processors.push(processor)
  }

  findProcessor(filePath: string): FileProcessor | null {
    return this.processors.find(p => {
      if (p.test instanceof RegExp) {
        return p.test.test(filePath)
      }
      return p.test(filePath)
    }) || null
  }
}
```

### 自定义文件处理器示例

```typescript
// 处理 .myext 文件的自定义处理器
const myExtProcessor: FileProcessor = {
  test: /\.myext$/,
  process: (content, filePath) => {
    // 自定义处理逻辑
    const transformedCode = transformMyExt(content)
    
    return {
      code: transformedCode,
      dependencies: extractDependencies(content)
    }
  }
}

// 注册处理器
const registry = new FileProcessorRegistry()
registry.register(myExtProcessor)
```

## 输出格式扩展

### 自定义输出格式

```typescript
interface OutputFormatHandler {
  name: string
  generateOptions: (
    baseOptions: OutputOptions,
    buildOptions: BuildOptions
  ) => OutputOptions
}

class OutputFormatRegistry {
  private handlers = new Map<string, OutputFormatHandler>()

  register(handler: OutputFormatHandler): void {
    this.handlers.set(handler.name, handler)
  }

  getHandler(format: string): OutputFormatHandler | null {
    return this.handlers.get(format) || null
  }
}
```

### 自定义格式示例

```typescript
// 自定义 SystemJS 格式
const systemjsHandler: OutputFormatHandler = {
  name: 'systemjs',
  generateOptions: (baseOptions, buildOptions) => ({
    ...baseOptions,
    format: 'system',
    entryFileNames: '[name].system.js',
    // 其他 SystemJS 特定配置
  })
}

// 注册格式处理器
const formatRegistry = new OutputFormatRegistry()
formatRegistry.register(systemjsHandler)

// 使用自定义格式
await build({
  input: 'src/index.ts',
  outDir: 'dist',
  formats: ['esm', 'cjs', 'systemjs'] // 包含自定义格式
})
```

## 模板系统扩展

### 项目模板接口

```typescript
interface ProjectTemplate {
  name: string
  description: string
  files: TemplateFile[]
  dependencies?: string[]
  devDependencies?: string[]
  scripts?: Record<string, string>
}

interface TemplateFile {
  path: string
  content: string | ((context: TemplateContext) => string)
}

interface TemplateContext {
  projectName: string
  typescript: boolean
  framework?: 'vue' | 'react'
  [key: string]: any
}
```

### 自定义模板示例

```typescript
const vueComponentTemplate: ProjectTemplate = {
  name: 'vue-component',
  description: 'Vue 3 组件库模板',
  files: [
    {
      path: 'src/index.ts',
      content: (ctx) => `export { default as ${ctx.componentName} } from './components/${ctx.componentName}.vue'`
    },
    {
      path: 'src/components/{{componentName}}.vue',
      content: `
<template>
  <div class="{{componentName}}">
    <!-- 组件内容 -->
  </div>
</template>

<script setup lang="ts">
// 组件逻辑
</script>

<style scoped>
.{{componentName}} {
  /* 样式 */
}
</style>
      `
    }
  ],
  dependencies: ['vue'],
  devDependencies: ['@vitejs/plugin-vue', 'typescript'],
  scripts: {
    build: 'ldesign-builder build',
    dev: 'ldesign-builder watch'
  }
}

// 注册模板
const templateRegistry = new TemplateRegistry()
templateRegistry.register(vueComponentTemplate)
```

## 中间件系统

### 中间件接口

```typescript
interface Middleware {
  name: string
  execute: (context: MiddlewareContext, next: () => Promise<void>) => Promise<void>
}

interface MiddlewareContext {
  scanResult: ProjectScanResult
  buildOptions: BuildOptions
  rollupConfig: RollupOptions
  [key: string]: any
}

class MiddlewareManager {
  private middlewares: Middleware[] = []

  use(middleware: Middleware): void {
    this.middlewares.push(middleware)
  }

  async execute(context: MiddlewareContext): Promise<void> {
    let index = 0

    const next = async (): Promise<void> => {
      if (index < this.middlewares.length) {
        const middleware = this.middlewares[index++]
        await middleware.execute(context, next)
      }
    }

    await next()
  }
}
```

### 中间件使用示例

```typescript
// 代码质量检查中间件
const codeQualityMiddleware: Middleware = {
  name: 'code-quality',
  execute: async (context, next) => {
    console.log('执行代码质量检查...')
    
    // 运行 ESLint
    await runESLint(context.scanResult.files)
    
    // 运行类型检查
    await runTypeCheck(context.scanResult.root)
    
    await next()
  }
}

// 性能分析中间件
const performanceMiddleware: Middleware = {
  name: 'performance',
  execute: async (context, next) => {
    const startTime = Date.now()
    
    await next()
    
    const endTime = Date.now()
    console.log(`构建耗时: ${endTime - startTime}ms`)
  }
}

// 使用中间件
const middlewareManager = new MiddlewareManager()
middlewareManager.use(performanceMiddleware)
middlewareManager.use(codeQualityMiddleware)
```

## 扩展开发指南

### 1. 插件开发

```typescript
// 1. 定义插件接口
interface MyPluginOptions {
  enabled: boolean
  customOption: string
}

// 2. 实现插件工厂
const createMyPlugin = (options: MyPluginOptions): PluginFactory => {
  return async (context) => {
    if (!options.enabled) return null

    return {
      name: 'my-plugin',
      transform(code, id) {
        // 插件逻辑
        return transformCode(code, options.customOption)
      }
    }
  }
}

// 3. 导出插件
export { createMyPlugin }
```

### 2. 配置扩展开发

```typescript
// 1. 扩展配置类型
declare module '@ldesign/builder' {
  interface BuildOptions {
    myCustomConfig?: {
      option1: string
      option2: boolean
    }
  }
}

// 2. 实现配置处理逻辑
export function processCustomConfig(config: BuildOptions): void {
  if (config.myCustomConfig) {
    // 处理自定义配置
  }
}
```

### 3. 发布扩展

```typescript
// package.json
{
  "name": "@my-org/ldesign-builder-plugin-xxx",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "keywords": ["ldesign-builder", "plugin"],
  "peerDependencies": {
    "@ldesign/builder": "^1.0.0"
  }
}
```
