# LDesign Builder - 实现细节

## 项目扫描实现

### 文件类型检测

```typescript
class ProjectScanner {
  private detectFileType(filePath: string): FileType {
    const ext = path.extname(filePath).toLowerCase()
    const typeMap: Record<string, FileType> = {
      '.ts': 'typescript',
      '.tsx': 'tsx',
      '.js': 'javascript',
      '.jsx': 'jsx',
      '.vue': 'vue',
      '.css': 'css',
      '.less': 'less',
      '.scss': 'scss',
      '.sass': 'sass',
      '.styl': 'stylus',
    }
    return typeMap[ext] || 'other'
  }
}
```

### 项目类型推断

项目类型推断基于以下规则：

1. **Vue 项目**：
   - 存在 `.vue` 文件
   - package.json 中依赖 `vue`
   - 存在 `vue.config.js` 或 `vite.config.ts`

2. **React 项目**：
   - 存在 `.jsx` 或 `.tsx` 文件
   - package.json 中依赖 `react`
   - 存在 React 相关配置文件

3. **TypeScript 项目**：
   - 存在 `.ts` 文件
   - 存在 `tsconfig.json`

### 依赖关系分析

```typescript
interface DependencyGraph {
  nodes: Map<string, FileNode>
  edges: DependencyEdge[]
}

interface FileNode {
  path: string
  type: FileType
  exports: string[]
  imports: string[]
}
```

## 插件配置实现

### 插件工厂模式

```typescript
type PluginFactory = (context: BuildContext) => Promise<Plugin | null>

class PluginConfigurator {
  private pluginRegistry = new Map<string, PluginFactory>()

  registerPlugin(name: string, factory: PluginFactory): void {
    this.pluginRegistry.set(name, factory)
  }

  async createPlugin(name: string, context: BuildContext): Promise<Plugin | null> {
    const factory = this.pluginRegistry.get(name)
    if (!factory) return null
    
    try {
      return await factory(context)
    } catch (error) {
      logger.warn(`插件 ${name} 创建失败: ${error.message}`)
      return null
    }
  }
}
```

### Vue 插件配置

```typescript
private createVuePlugin: PluginFactory = async (context) => {
  try {
    const { default: vue } = await import('unplugin-vue/rollup')
    return vue({
      include: /\.vue$/,
      ...context.options.vue,
    })
  } catch (error) {
    logger.warn('无法加载 unplugin-vue')
    return null
  }
}

private createVueJsxPlugin: PluginFactory = async (context) => {
  try {
    const { default: vueJsx } = await import('unplugin-vue-jsx/rollup')
    const plugin = vueJsx({
      include: /\.[jt]sx$/,
      ...context.options.vueJsx,
    })
    return Array.isArray(plugin) ? plugin[0] : plugin
  } catch (error) {
    logger.warn('无法加载 unplugin-vue-jsx')
    return null
  }
}
```

### TypeScript 插件配置

```typescript
private createTypescriptPlugin: PluginFactory = async (context) => {
  try {
    const { default: typescript } = await import('@rollup/plugin-typescript')
    return typescript({
      tsconfig: context.options.tsconfig || 'tsconfig.json',
      declaration: context.options.dts !== false,
      declarationDir: context.options.dtsDir || 'dist/types',
      ...context.options.typescript,
    })
  } catch (error) {
    logger.warn('无法加载 @rollup/plugin-typescript')
    return null
  }
}
```

## 多格式输出实现

### 输出目录结构

```
dist/
├── esm/           # ES 模块格式，保持目录结构
│   ├── components/
│   ├── utils/
│   └── index.js
├── cjs/           # CommonJS 格式，保持目录结构
│   ├── components/
│   ├── utils/
│   └── index.js
├── umd/           # UMD 格式，单文件输出
│   └── index.umd.js
└── types/         # TypeScript 声明文件
    ├── components/
    ├── utils/
    └── index.d.ts
```

### 格式特定配置

```typescript
private getFormatSpecificOptions(
  format: OutputFormat,
  scanResult: ProjectScanResult,
  buildOptions: BuildOptions,
): Partial<OutputOptions> {
  const options: Partial<OutputOptions> = {}

  switch (format) {
    case 'esm':
      // ESM 格式特定配置
      break

    case 'cjs':
      options.exports = 'auto'
      break

    case 'umd':
      // UMD 格式不保持模块结构，使用单文件输出
      options.entryFileNames = '[name].umd.js'
      options.name = buildOptions.name || scanResult.packageInfo?.name || 'MyLibrary'
      options.globals = buildOptions.globals || {}
      break
  }

  return options
}
```

## 类型生成实现

### TypeScript 编译器 API

```typescript
class TypeGenerator {
  async generate(scanResult: ProjectScanResult, options: TypeGenerationOptions): Promise<void> {
    const program = ts.createProgram(
      scanResult.files.filter(f => f.type === 'typescript').map(f => f.path),
      {
        declaration: true,
        emitDeclarationOnly: true,
        outDir: options.outDir,
        ...options.compilerOptions,
      }
    )

    const emitResult = program.emit()
    
    if (emitResult.diagnostics.length > 0) {
      this.handleDiagnostics(emitResult.diagnostics)
    }
  }
}
```

## 错误处理实现

### 统一错误处理

```typescript
class ErrorHandler {
  static handle(error: unknown): BuildError {
    if (error instanceof BuildError) {
      return error
    }

    if (error instanceof Error) {
      return {
        message: error.message,
        stack: error.stack,
        file: 'file' in error ? String(error.file) : undefined,
        line: 'line' in error ? Number(error.line) : undefined,
        column: 'column' in error ? Number(error.column) : undefined,
      }
    }

    return {
      message: String(error),
    }
  }
}
```

### Rollup 错误处理

```typescript
const rollupOptions: RollupOptions = {
  // ...其他配置
  onwarn: (warning) => {
    logger.warn(`Rollup警告: ${warning.message}`)
  },
}

try {
  const bundle = await rollup(rollupOptions)
  // 构建逻辑
} catch (error) {
  const buildError = ErrorHandler.handle(error)
  logger.error('构建失败:', buildError.message)
  throw buildError
}
```

## 性能优化实现

### 并发文件扫描

```typescript
async scan(root: string, options: ScanOptions): Promise<ProjectScanResult> {
  const files = await this.findFiles(root, options)
  
  // 并发处理文件
  const fileInfos = await Promise.all(
    files.map(async (filePath) => {
      const info = await this.analyzeFile(filePath)
      return info
    })
  )

  return {
    root,
    files: fileInfos,
    // ...其他结果
  }
}
```

### 插件懒加载

```typescript
private async createPlugin(name: string, context: BuildContext): Promise<Plugin | null> {
  // 只有在需要时才加载插件
  const factory = this.pluginRegistry.get(name)
  if (!factory) return null

  try {
    return await factory(context)
  } catch (error) {
    // 插件加载失败时的降级处理
    logger.warn(`插件 ${name} 加载失败，跳过`)
    return null
  }
}
```

## 配置系统实现

### 配置合并策略

```typescript
function mergeConfig<T>(base: T, override: Partial<T>): T {
  const result = { ...base }
  
  for (const [key, value] of Object.entries(override)) {
    if (value !== undefined) {
      if (typeof value === 'object' && !Array.isArray(value)) {
        result[key] = mergeConfig(result[key] || {}, value)
      } else {
        result[key] = value
      }
    }
  }
  
  return result
}
```

### 配置文件加载

```typescript
async loadConfig(configPath?: string): Promise<BuildConfig> {
  const configFiles = [
    '.ldesign/builder.config.ts',
    '.ldesign/builder.config.js',
    '.ldesign/builder.config.mjs',
    'ldesign.config.ts',
    'ldesign.config.js',
    'ldesign.config.mjs',
  ]

  for (const file of configFiles) {
    const fullPath = path.resolve(configPath || process.cwd(), file)
    if (await fs.pathExists(fullPath)) {
      return await this.loadConfigFile(fullPath)
    }
  }

  return {}
}
```
