{"version":3,"file":"distribute-types.test.js","sourceRoot":"","sources":["../../../../src/__tests__/adapters/rollup/distribute-types.test.ts"],"names":[],"mappings":"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","sourcesContent":["import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { RollupAdapter } from '../../../adapters/rollup/RollupAdapter'\nimport { promises as fs } from 'fs'\n\n// Mock fs-extra\nvi.mock('fs-extra', () => ({\n  pathExists: vi.fn(),\n  copy: vi.fn(),\n}))\n\n// Mock fs for lstatSync\nvi.mock('fs', () => ({\n  lstatSync: vi.fn(),\n}))\n\ndescribe('RollupAdapter.distributeTypes', () => {\n  let adapter: RollupAdapter\n  let mockPathExists: any\n  let mockCopy: any\n  let mockLstatSync: any\n\n  beforeEach(async () => {\n    adapter = new RollupAdapter({})\n    \n    // 动态导入 mock\n    const fse = await import('fs-extra')\n    const fsSync = await import('fs')\n    \n    mockPathExists = vi.mocked(fse.pathExists)\n    mockCopy = vi.mocked(fse.copy)\n    mockLstatSync = vi.mocked(fsSync.lstatSync)\n  })\n\n  afterEach(() => {\n    vi.clearAllMocks()\n  })\n\n  it('should skip distribution when types directory does not exist', async () => {\n    mockPathExists.mockResolvedValue(false)\n\n    // 通过反射调用私有方法\n    await (adapter as any).distributeTypes()\n\n    expect(mockPathExists).toHaveBeenCalledWith('types')\n    expect(mockCopy).not.toHaveBeenCalled()\n  })\n\n  it('should copy types to es and lib directories', async () => {\n    mockPathExists.mockResolvedValue(true)\n    mockLstatSync.mockReturnValue({ isDirectory: () => true })\n    mockCopy.mockResolvedValue(undefined)\n\n    await (adapter as any).distributeTypes()\n\n    expect(mockPathExists).toHaveBeenCalledWith('types')\n    expect(mockCopy).toHaveBeenCalledTimes(2)\n    expect(mockCopy).toHaveBeenCalledWith('types', 'es', expect.objectContaining({\n      overwrite: true,\n      filter: expect.any(Function)\n    }))\n    expect(mockCopy).toHaveBeenCalledWith('types', 'lib', expect.objectContaining({\n      overwrite: true,\n      filter: expect.any(Function)\n    }))\n  })\n\n  it('should filter only .d.ts files and directories', async () => {\n    mockPathExists.mockResolvedValue(true)\n    mockCopy.mockImplementation((src, dest, options) => {\n      // 测试过滤器函数\n      const filter = options.filter\n      \n      // 模拟目录\n      mockLstatSync.mockReturnValue({ isDirectory: () => true })\n      expect(filter('some/dir')).toBe(true)\n      \n      // 模拟 .d.ts 文件\n      mockLstatSync.mockReturnValue({ isDirectory: () => false })\n      expect(filter('types/index.d.ts')).toBe(true)\n      expect(filter('types/utils.d.cts')).toBe(true)\n      expect(filter('types/module.d.mts')).toBe(true)\n      \n      // 模拟非声明文件\n      expect(filter('types/index.js')).toBe(false)\n      expect(filter('types/style.css')).toBe(false)\n      \n      return Promise.resolve()\n    })\n\n    await (adapter as any).distributeTypes()\n\n    expect(mockCopy).toHaveBeenCalledTimes(2)\n  })\n\n  it('should handle copy errors gracefully', async () => {\n    mockPathExists.mockResolvedValue(true)\n    mockCopy.mockRejectedValue(new Error('Copy failed'))\n\n    // 应该不抛出异常\n    await expect((adapter as any).distributeTypes()).resolves.toBeUndefined()\n  })\n})\n"]}